export const state = () => ({
  searchTerm: '',
  selectedStatus: 'all',
  selectedLocation: 'all',
  selectedCarModel: 'all',
  selectedSalesRep: 'all',
  selectedCustomerType: 'all',
  dateRange: {
    start: '',
    end: ''
  },
  advancedSearchOpen: false,
  queues: [],
  loading: false,
  error: null
})

export const mutations = {
  setSearchTerm(state, term) {
    state.searchTerm = term
  },
  setSelectedStatus(state, status) {
    state.selectedStatus = status
  },
  setSelectedLocation(state, location) {
    state.selectedLocation = location
  },
  setSelectedCarModel(state, carModel) {
    state.selectedCarModel = carModel
  },
  setSelectedSalesRep(state, salesRep) {
    state.selectedSalesRep = salesRep
  },
  setSelectedCustomerType(state, customerType) {
    state.selectedCustomerType = customerType
  },
  setDateRange(state, dateRange) {
    state.dateRange = dateRange
  },
  setAdvancedSearchOpen(state, open) {
    state.advancedSearchOpen = open
  },
  clearFilters(state) {
    state.searchTerm = ''
    state.selectedStatus = 'all'
    state.selectedLocation = 'all'
    state.selectedCarModel = 'all'
    state.selectedSalesRep = 'all'
    state.selectedCustomerType = 'all'
    state.dateRange = { start: '', end: '' }
  },
  setQueues(state, queues) {
    state.queues = queues
  },
  addQueue(state, queue) {
    state.queues.unshift(queue)
  },
  updateQueue(state, { id, queue }) {
    const index = state.queues.findIndex(q => q.id === id)
    if (index !== -1) {
      state.queues.splice(index, 1, { ...queue, id })
    }
  },
  deleteQueue(state, id) {
    state.queues = state.queues.filter(q => q.id !== id)
  },
  setLoading(state, loading) {
    state.loading = loading
  },
  setError(state, error) {
    state.error = error
  }
}

export const actions = {
  async fetchQueues({ commit }) {
    try {
      commit('setLoading', true)
      commit('setError', null)
      
      // เรียก API จริง
      // const response = await this.$api.testDrives.getAll()
      // Mock data สำหรับ development
      const mockResponse = {
        data: [
          {
            id: "TD241216001",
            customerName: "คุณสมชาย โอดี",
            phone: "081-234-5678",
            email: "somchai@email.com",
            vehicleModel: "D-MAX Blue Power 1.9 Ddi Z Hi-Lander",
            timeSlot: "09:00",
            date: "16 ธ.ค. 2567",
            duration: "60 นาที",
            salesRep: "คุณสมชาย โอดี",
            customerType: "VIP",
            location: "ชั้น 1 โชว์รูม",            status: "scheduled"
          },
          {
            id: "TD241216002",
            customerName: "คุณสมฤดี ปันปี",
            phone: "089-876-5432",
            email: "somrudee@email.com",
            vehicleModel: "MU-X Blue Power 3.0 Ddi Supreme",
            timeSlot: "10:30",
            date: "16 ธ.ค. 2567",
            duration: "90 นาที",
            status: "in-progress"
          }
        ]
      }
      const response = mockResponse      
      // แปลงข้อมูลจาก API ให้ตรงกับ frontend
      const queues = response.data.map(item => ({
        id: item.id,
        customerName: item.customerName,
        phone: item.phone,
        email: item.email,
        carModel: item.vehicleModel,
        timeSlot: item.timeSlot,
        date: item.date,
        duration: item.duration,
        status: item.status,
        priority: item.priority || 'medium',
        location: item.location,
        salesRep: item.salesRep,
        leadSource: item.leadSource,
        expectedRevenue: item.expectedRevenue,
        customerType: item.customerType,
        notes: item.notes,
        createdAt: item.createdAt,
        updatedAt: item.updatedAt
      }))
      
      commit('setQueues', queues)
    } catch (error) {
      console.error('Error fetching queues:', error)
      commit('setError', 'ไม่สามารถดึงข้อมูลได้ กำลังใช้ข้อมูลตัวอย่าง')
      
      // ถ้า API ไม่พร้อม ใช้ mock data
      await this.dispatch('dashboard/loadMockData')
    } finally {
      commit('setLoading', false)
    }
  },

  async createQueue({ commit }, queueData) {
    try {
      commit('setLoading', true)
      commit('setError', null)
      
      // แปลงข้อมูลให้ตรงกับ API schema
      const apiData = {
        customerName: queueData.customerName,
        phone: queueData.phone,
        email: queueData.email,
        vehicleModel: queueData.carModel,
        timeSlot: queueData.timeSlot,
        date: queueData.date,
        duration: parseInt(queueData.duration),
        location: queueData.location,
        salesRep: queueData.salesRep,
        leadSource: queueData.leadSource,
        expectedRevenue: queueData.expectedRevenue ? parseInt(queueData.expectedRevenue) : null,
        customerType: queueData.customerType,
        priority: queueData.priority,
        notes: queueData.notes
      }
      
      const response = await this.$api.testDrives.create(apiData)
      
      // แปลงกลับเป็นรูปแบบที่ frontend ใช้
      const newQueue = {
        id: response.data.id,
        customerName: response.data.customerName,
        phone: response.data.phone,
        email: response.data.email,
        carModel: response.data.vehicleModel,
        timeSlot: response.data.timeSlot,
        date: response.data.date,
        duration: response.data.duration,
        status: response.data.status,
        priority: response.data.priority,
        location: response.data.location,
        salesRep: response.data.salesRep,
        leadSource: response.data.leadSource,
        expectedRevenue: response.data.expectedRevenue,
        customerType: response.data.customerType,
        notes: response.data.notes,
        createdAt: response.data.createdAt,
        updatedAt: response.data.updatedAt
      }
      
      commit('addQueue', newQueue)
      return { success: true, data: newQueue }
    } catch (error) {
      console.error('Error creating queue:', error)
      const errorMessage = error.response?.data?.message || 'เกิดข้อผิดพลาดในการสร้างคิว'
      commit('setError', errorMessage)
      return { success: false, error: errorMessage }
    } finally {
      commit('setLoading', false)
    }
  },

  async updateQueue({ commit }, { id, queueData }) {
    try {
      commit('setLoading', true)
      commit('setError', null)
      
      const apiData = {
        customerName: queueData.customerName,
        phone: queueData.phone,
        email: queueData.email,
        vehicleModel: queueData.carModel,
        timeSlot: queueData.timeSlot,
        date: queueData.date,
        duration: parseInt(queueData.duration),
        location: queueData.location,
        salesRep: queueData.salesRep,
        leadSource: queueData.leadSource,
        expectedRevenue: queueData.expectedRevenue ? parseInt(queueData.expectedRevenue) : null,
        customerType: queueData.customerType,
        priority: queueData.priority,
        notes: queueData.notes,
        status: queueData.status
      }
      
      const response = await this.$api.testDrives.update(id, apiData)
      
      const updatedQueue = {
        id: response.data.id,
        customerName: response.data.customerName,
        phone: response.data.phone,
        email: response.data.email,
        carModel: response.data.vehicleModel,
        timeSlot: response.data.timeSlot,
        date: response.data.date,
        duration: response.data.duration,
        status: response.data.status,
        priority: response.data.priority,
        location: response.data.location,
        salesRep: response.data.salesRep,
        leadSource: response.data.leadSource,
        expectedRevenue: response.data.expectedRevenue,
        customerType: response.data.customerType,
        notes: response.data.notes,
        createdAt: response.data.createdAt,
        updatedAt: response.data.updatedAt
      }
      
      commit('updateQueue', { id, queue: updatedQueue })
      return { success: true, data: updatedQueue }
    } catch (error) {
      console.error('Error updating queue:', error)
      const errorMessage = error.response?.data?.message || 'เกิดข้อผิดพลาดในการอัปเดตคิว'
      commit('setError', errorMessage)
      return { success: false, error: errorMessage }
    } finally {
      commit('setLoading', false)
    }
  },

  async deleteQueue({ commit }, id) {
    try {
      commit('setLoading', true)
      commit('setError', null)
      
      await this.$api.testDrives.delete(id)
      commit('deleteQueue', id)
      return { success: true }
    } catch (error) {
      console.error('Error deleting queue:', error)
      const errorMessage = error.response?.data?.message || 'เกิดข้อผิดพลาดในการลบคิว'
      commit('setError', errorMessage)
      return { success: false, error: errorMessage }
    } finally {
      commit('setLoading', false)
    }
  },

  // Fallback mock data
  async loadMockData({ commit }) {
    const mockData = [
      {
        id: 'TD241216001',
        customerName: 'คุณสมชาย โอดี',
        phone: '081-234-5678',
        email: 'somchai.o@gmail.com',
        carModel: 'D-MAX Blue Power 1.9 Ddi Z Hi-Lander',
        timeSlot: '09:00',
        date: '2024-12-16',
        duration: 60,
        status: 'in-progress',
        priority: 'high',
        location: 'สาขาเซ็นทรัล บางนา',
        salesRep: 'คุณจิรายุ ธนาสมบัติ',
        leadSource: 'เว็บไซต์',
        expectedRevenue: 850000,
        customerType: 'VIP',
        notes: 'ลูกค้า VIP ต้องการทดสอบในสนามทดสอบพิเศษ',
        createdAt: '2024-12-15T10:30:00.000Z',
        updatedAt: '2024-12-15T14:20:00.000Z'
      },
      {
        id: 'TD241216002',
        customerName: 'คุณสมหญิง ปั่นมี',
        phone: '089-876-5432',
        email: 'somying.p@company.co.th',
        carModel: 'MU-X Blue Power 3.0 Ddi Supreme',
        timeSlot: '10:30',
        date: '2024-12-16',
        duration: 90,
        status: 'scheduled',
        priority: 'medium',
        location: 'สาขาอีสท์วิลล์',
        salesRep: 'คุณสุดา กิตติขุน',
        leadSource: 'โซเชียลมีเดีย',
        expectedRevenue: 1200000,
        customerType: 'ครอบครัว',
        notes: 'ต้องการนำครอบครัวมาทดสอบด้วย',
        createdAt: '2024-12-14T09:15:00.000Z',
        updatedAt: '2024-12-14T09:15:00.000Z'
      }
    ]
    
    commit('setQueues', mockData)
  }
}

export const getters = {
  filteredQueues: (state) => {
    return state.queues.filter(queue => {
      const matchesSearch = !state.searchTerm ||
        queue.customerName.toLowerCase().includes(state.searchTerm.toLowerCase()) ||
        queue.carModel.toLowerCase().includes(state.searchTerm.toLowerCase()) ||
        queue.id.toLowerCase().includes(state.searchTerm.toLowerCase()) ||
        queue.phone.includes(state.searchTerm) ||
        (queue.email && queue.email.toLowerCase().includes(state.searchTerm.toLowerCase())) ||
        (queue.salesRep && queue.salesRep.toLowerCase().includes(state.searchTerm.toLowerCase()))

      const matchesStatus = state.selectedStatus === 'all' || queue.status === state.selectedStatus
      const matchesLocation = state.selectedLocation === 'all' || queue.location === state.selectedLocation
      const matchesCarModel = state.selectedCarModel === 'all' || queue.carModel.includes(state.selectedCarModel)
      const matchesSalesRep = state.selectedSalesRep === 'all' || queue.salesRep === state.selectedSalesRep
      const matchesCustomerType = state.selectedCustomerType === 'all' || queue.customerType === state.selectedCustomerType

      let matchesDateRange = true
      if (state.dateRange.start && state.dateRange.end) {
        const queueDate = new Date(queue.date)
        const startDate = new Date(state.dateRange.start)
        const endDate = new Date(state.dateRange.end)
        matchesDateRange = queueDate >= startDate && queueDate <= endDate
      }

      return matchesSearch && matchesStatus && matchesLocation && 
             matchesCarModel && matchesSalesRep && matchesCustomerType && matchesDateRange
    }).sort((a, b) => {
      const dateA = new Date(`${a.date}T${a.timeSlot}:00`)
      const dateB = new Date(`${b.date}T${b.timeSlot}:00`)
      return dateA - dateB
    })
  },
  
  statsData: (state, getters) => {
    const filtered = getters.filteredQueues
    return {
      total: filtered.length,
      inProgress: filtered.filter(q => q.status === 'in-progress').length,
      scheduled: filtered.filter(q => q.status === 'scheduled').length,
      completed: filtered.filter(q => q.status === 'completed').length,
      cancelled: filtered.filter(q => q.status === 'cancelled').length
    }
  },

  getQueueById: (state) => (id) => {
    return state.queues.find(queue => queue.id === id)
  }
}
